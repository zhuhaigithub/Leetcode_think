1.kmp的核心思想：
假设模式串p的p[j]与主串的s的s[i]失配，那么可以肯定的是p[0]-p[j-1]一定与主串s中某处到s[i-1]匹配，也就是一摸一样。那么我们能否利用这些已经得到的信息来使模式串多移动几位，以此来减少遍历次数呢？答案是肯定的。

2.之前要了解前缀和后缀：
"前缀"指除了最后一个字符以外，一个字符串的全部头部组合。
"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。

匹配的部分如果有前缀和后缀相同的情况，如abcabc,就可以使模式串多移动几位。
那就需要知道模式串的这种情况到底是怎样的。

3.这就是计算模式串的next数组。
之前先计算：模式串的子串对应的各个前缀后缀的公共元素的最大长度表
而next数组考虑的是除当前字符外的最长相同前缀后缀
next数组等于最大长度表整体右移一位，初值赋-1

4.通过递推计算next数组：
已知next [0, ..., j]，如何求出next [j + 1]呢？

对于P的前j+1个序列字符：已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” ）

若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；
若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀"p0 p1, …, pk-1 pk"跟后缀“pj-k pj-k+1, …, pj-1 pj"相等，那么是否可能存在另一个值t+1 < k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, ..., k, ..., j]）进行P串前缀跟P串后缀的匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。


参考：
https://blog.csdn.net/v_JULY_v/article/details/7041827
